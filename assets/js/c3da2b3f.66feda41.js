"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[119],{5535:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"core-concepts/data-sources","title":"Data Sources","description":"A data source represents what data will be rendered in the list. For example, the data for a chat room would be the messages sent, as well as metadata such as who sent them.","source":"@site/docs/core-concepts/data-sources.md","sourceDirName":"core-concepts","slug":"/core-concepts/data-sources","permalink":"/ultimate-list/core-concepts/data-sources","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/core-concepts/data-sources.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Core Concepts","permalink":"/ultimate-list/core-concepts/intro"},"next":{"title":"Dimensions","permalink":"/ultimate-list/core-concepts/dimensions"}}');var r=n(4848),a=n(8453);const i={sidebar_position:2},o="Data Sources",c={},d=[{value:"Arrays",id:"arrays",level:2},{value:"Mutable sources",id:"mutable-sources",level:2},{value:"Required fields",id:"required-fields",level:3},{value:"<code>get: (startIndex: number) -&gt; DataSourceCursor&lt;T&gt;?</code>",id:"get-startindex-number---datasourcecursort",level:4},{value:"<code>length: () -&gt; number</code>",id:"length----number",level:4},{value:"<code>bindToChanged: (callback: () -&gt; ()) -&gt; () -&gt; ()</code>",id:"bindtochanged-callback----------",level:4},{value:"Optional fields",id:"optional-fields",level:3},{value:"<code>back: () -&gt; T?</code>",id:"back----t",level:4},{value:"<code>getByRange: (startIndex: number, endIndex: number) -&gt; { T }</code>",id:"getbyrange-startindex-number-endindex-number----t-",level:4}];function l(e){const t={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components},{Details:n}=t;return n||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"data-sources",children:"Data Sources"})}),"\n",(0,r.jsx)(t.p,{children:"A data source represents what data will be rendered in the list. For example, the data for a chat room would be the messages sent, as well as metadata such as who sent them."}),"\n",(0,r.jsx)(t.admonition,{type:"warning",children:(0,r.jsxs)(t.p,{children:["Whatever data source you choose, elements ",(0,r.jsx)(t.strong,{children:"must"})," be sorted in ascending order."]})}),"\n",(0,r.jsx)(t.h2,{id:"arrays",children:"Arrays"}),"\n",(0,r.jsxs)(t.p,{children:["The easiest data source to provide is a simple array. This can be done through ",(0,r.jsx)(t.code,{children:"UltimateList.DataSources.array"}),". This array must be immutable like React state usually is--you must provide a different array to the UltimateList in order to update it."]}),"\n",(0,r.jsx)(t.p,{children:"In the introduction example, we saw this:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-lua",children:'local e = React.createElement\n\nlocal letters = {}\nfor offset = 0, 25 do\n    table.insert(letters, string.char(string.byte("A") + offset))\nend\n\nreturn e(UltimateList.Components.ScrollingFrame, {\n    dataSource = UltimateList.DataSources.array(letters),\n\n    -- Rest omitted...\n})\n'})}),"\n",(0,r.jsx)(t.p,{children:"If we wanted something more dynamic, it might look something like this:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-lua",children:'local e = React.createElement\n\nlocal letters: { string }, setLetters = React.useState({} :: { string })\n\nReact.useEffect(function()\n    local thread = task.spawn(function()\n        for offset = 0, 25 do\n            -- Update the `letters` state, but never mutating the array.\n            setLetters(function(newLetters)\n                newLetters = table.clone(newLetters)\n                table.insert(newLetters, string.char(string.byte("A") + offset))\n                return newLetters\n            end)\n\n            task.wait(0.5)\n        end\n    end)\n\n    return function()\n        task.cancel(thread)\n    end\nend, {})\n\nreturn e(UltimateList.Components.ScrollingFrame, {\n    dataSource = UltimateList.DataSources.array(letters),\n\n    -- Rest omitted...\n})\n'})}),"\n",(0,r.jsx)(t.h2,{id:"mutable-sources",children:"Mutable sources"}),"\n",(0,r.jsx)(t.admonition,{type:"info",children:(0,r.jsxs)(t.p,{children:["Mutable sources are an advanced feature. You can probably just use ",(0,r.jsx)(t.a,{href:"#arrays",children:"arrays"}),"."]})}),"\n",(0,r.jsxs)(t.p,{children:["Sometimes the cost of updating an array can be too expensive, or will incur a React re-render that you wouldn't otherwise want. In the case where this poses a performance issue, you can opt instead for a ",(0,r.jsx)(t.strong,{children:"mutable source"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["A mutable source assumes nothing about the underlying data, and instead calls to methods you provide for getting it and alerting it to changes. This is done through ",(0,r.jsx)(t.code,{children:"UltimateList.DataSources.mutableSource(mutableSourceMethods)"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"mutableSourceMethods"})," is a table with the following fields:"]}),"\n",(0,r.jsx)(t.h3,{id:"required-fields",children:"Required fields"}),"\n",(0,r.jsx)(t.h4,{id:"get-startindex-number---datasourcecursort",children:(0,r.jsx)(t.code,{children:"get: (startIndex: number) -> DataSourceCursor<T>?"})}),"\n",(0,r.jsx)(t.p,{children:"Given an index, provides a cursor that points to that value, if it exists, as well as provides a way to go forwards and backwards."}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"DataSourceCursor<T>"})," is defined as follows:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"type DataSourceCursor<T> = {\n    before: () -> DataSourceCursor<T>?,\n    value: T,\n    after: () -> DataSourceCursor<T>?,\n}\n"})}),"\n",(0,r.jsxs)(t.p,{children:["If you only have a function for going from index to value, then you can use ",(0,r.jsx)(t.code,{children:"DataSources.utilities.createGetSimpleCursor"})," to produce this for you."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"DataSources.utilities.createGetSimpleCursor<T>(\n    get: (index: number) -> T,\n    getLength: () -> number,\n)\n"})}),"\n",(0,r.jsx)(t.p,{children:"This can be used like so:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-lua",children:"UltimateList.DataSources.mutableSource({\n    get = DataSources.utilities.createGetSimpleCursor(\n        -- Getter\n        function(index: number): T\n            -- Note that we return `T` and not `T?`.\n            -- UltimateList will never provide an index not in the range of 1 <= index <= length,\n            -- and thus every element being requested is expected to exist.\n            return myData[index]\n        end,\n\n        -- Get length\n        function(): number\n            return #number\n        end\n    ),\n\n    -- Other required fields...\n})\n"})}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsxs)("summary",{children:["Why does ",(0,r.jsx)(t.code,{children:"get"})," return a cursor instead of just the item?"]}),(0,r.jsxs)(t.p,{children:["Some data structures have a different time complexity for going forwards/backwards than for indexing. For example, a binary search tree provides ",(0,r.jsx)(t.code,{children:"O(log n)"})," access, meaning getting m elements naively is ",(0,r.jsx)(t.code,{children:"O(m log n)"}),". However, going from an existing element to the element before or afterwards is ",(0,r.jsx)(t.code,{children:"O(1)"}),": getting the previous element is going to the left in the tree, and getting the next element is going to the right."]}),(0,r.jsx)(t.p,{children:"These kinds of tree-like structures are expected for specific use cases, such as the data model instance tree where elements can be removed or inserted anywhere in the collection."})]}),"\n",(0,r.jsx)(t.h4,{id:"length----number",children:(0,r.jsx)(t.code,{children:"length: () -> number"})}),"\n",(0,r.jsx)(t.p,{children:"This returns the length of the data source."}),"\n",(0,r.jsx)(t.h4,{id:"bindtochanged-callback----------",children:(0,r.jsx)(t.code,{children:"bindToChanged: (callback: () -> ()) -> () -> ()"})}),"\n",(0,r.jsx)(t.p,{children:"This function takes a callback that will be called when the data updates, and returns a function to disconnect that callback when it is no longer necessary."}),"\n",(0,r.jsxs)(n,{children:[(0,r.jsx)("summary",{children:"That's a lot of parentheses, how do I read that type signature?"}),(0,r.jsx)(t.p,{children:"Let's work our way to it by starting with a function that takes nothing, and returns nothing."}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"bindToChanged: () -> ()"})}),(0,r.jsx)(t.p,{children:"Now we want to return the destructor. In other words, a function that returns a function."}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"bindToChanged: () -> () -> ()"})}),(0,r.jsx)(t.p,{children:"Now, let's make it take a callback, another function that takes nothing and returns nothing."}),(0,r.jsx)(t.p,{children:(0,r.jsx)(t.code,{children:"bindToChanged: (callback: () -> ()) -> () -> ()"})}),(0,r.jsx)(t.p,{children:"If it helps, you can also imagine this with type aliases:"}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-ts",children:"type Callback = () -> ()\n\n// ...\nbindToChanged: (Callback) -> Callback\n"})})]}),"\n",(0,r.jsx)(t.h3,{id:"optional-fields",children:"Optional fields"}),"\n",(0,r.jsx)(t.p,{children:"Some data structures offer extra opportunities for optimization in special use cases, but these provide reasonable defaults when that's not the case."}),"\n",(0,r.jsx)(t.h4,{id:"back----t",children:(0,r.jsx)(t.code,{children:"back: () -> T?"})}),"\n",(0,r.jsxs)(t.p,{children:["This returns the last element in the data source. It defaults to the result of ",(0,r.jsx)(t.code,{children:"get(length())"}),"."]}),"\n",(0,r.jsx)(t.p,{children:"An example of a data source that might implement this is a binary search tree, where getting the last element can be done efficiently by repeatedly going through the rightmost node."}),"\n",(0,r.jsx)(t.h4,{id:"getbyrange-startindex-number-endindex-number----t-",children:(0,r.jsx)(t.code,{children:"getByRange: (startIndex: number, endIndex: number) -> { T }"})}),"\n",(0,r.jsxs)(t.p,{children:["This returns elements from startIndex to (and including) endIndex. It defaults to ",(0,r.jsx)(t.code,{children:"get(startIndex)"}),", and then repeatedly calling ",(0,r.jsx)(t.code,{children:".after()"}),"."]}),"\n",(0,r.jsxs)(t.p,{children:["A data source built over a simple array might use this to specialize for using ",(0,r.jsx)(t.code,{children:"table.move"}),", which is more efficient than getting each element individually."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var s=n(6540);const r={},a=s.createContext(r);function i(e){const t=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);