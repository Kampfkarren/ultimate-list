"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[815],{1562:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/medias/multiple_items-68814a516544ec23ea5ebea8102354ea.mp4"},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var i=n(6540);const s={},r=i.createContext(s);function o(e){const t=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(r.Provider,{value:t},e.children)}},8593:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"guides/supporting-different-items","title":"Supporting different items","description":"Let\'s make a virtualized list that combines different kinds of items, in this case categories of continents, and a list of countries underneath.","source":"@site/docs/guides/supporting-different-items.mdx","sourceDirName":"guides","slug":"/guides/supporting-different-items","permalink":"/ultimate-list/guides/supporting-different-items","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/guides/supporting-different-items.mdx","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"docsSidebar","previous":{"title":"Styling","permalink":"/ultimate-list/guides/styling"},"next":{"title":"API Reference","permalink":"/ultimate-list/api-reference"}}');var s=n(4848),r=n(8453);const o={sidebar_position:2},a="Supporting different items",c={},d=[];function l(e){const t={a:"a",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"supporting-different-items",children:"Supporting different items"})}),"\n",(0,s.jsx)(t.p,{children:"Let's make a virtualized list that combines different kinds of items, in this case categories of continents, and a list of countries underneath."}),"\n",(0,s.jsx)("video",{width:"250",controls:!0,children:(0,s.jsx)("source",{src:n(1562).A,type:"video/mp4"})}),"\n",(0,s.jsx)(t.p,{children:"First, we're going to create a tagged union representing our items. That means we have one type that can refer to multiple things."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:'type Item =\n    {\n        type: "category",\n        name: string,\n    }\n    | {\n        type: "text",\n        text: string,\n    }\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Next, we are going to prepare to use ",(0,s.jsx)(t.a,{href:"../core-concepts/dimensions#dynamically-determined-size-and-position",children:"a getter dimension"}),", since these items have different heights. Recall that a getter dimension is stateless, meaning you will only get the item you have. Therefore, let's create a second type that includes this information:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-ts",children:"type ItemWithUDimRect = {\n    item: Item,\n    udimRect: UltimateList.UDimRect,\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"Now we'll prepare that list."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:'-- Assuming ITEMS is an array of Item...\nlocal itemsWithUDimRects: { ItemWithUDimRect } = {}\nlocal nextPosition = UDim2.new()\n\nfor _, item in ITEMS do\n    local height = if item.type == "category" then 32 else 24\n\n    table.insert(itemsWithUDimRects, {\n        item = item,\n        udimRect = {\n            size = UDim2.new(1, 0, 0, height),\n            position = nextPosition,\n        },\n    })\n\n    nextPosition += UDim2.fromOffset(0, height)\nend\n'})}),"\n",(0,s.jsxs)(t.p,{children:["We use the type of the item to determine its height, and then use that information to prepare the position of the succeeding elements. Now, let's prepare the scrolling frame. We'll pass in ",(0,s.jsx)(t.code,{children:"itemsWithUDimRects"})," to our ScrollingFrame, and use that data in ",(0,s.jsx)(t.code,{children:"getter"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:'ScrollingFrame = e(UltimateList.Components.ScrollingFrame, {\n    dataSource = UltimateList.DataSources.array(itemsWithUDimRects),\n    dimensions = UltimateList.Dimensions.getter(function(itemWithUDimRect: ItemWithUDimRect)\n        return itemWithUDimRect.udimRect\n    end),\n    renderer = UltimateList.Renderers.byState(function(itemWithUDimRect: ItemWithUDimRect)\n        -- soon...\n    end),\n\n    direction = "y",\n}),\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Finally, let's render different things based on the item we have. Once again, we check the ",(0,s.jsx)(t.code,{children:"type"})," field to know what we are."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-lua",children:'renderer = UltimateList.Renderers.byState(function(itemWithUDimRect: ItemWithUDimRect)\n    if itemWithUDimRect.item.type == "category" then\n        return e("TextLabel", {\n            BackgroundColor3 = Color3.new(1, 1, 1),\n            Font = Enum.Font.BuilderSansBold,\n            Text = itemWithUDimRect.item.name,\n            TextColor3 = Color3.new(0, 0, 0),\n            TextSize = 30,\n            Size = UDim2.fromScale(1, 1),\n        })\n    else\n        return e("TextLabel", {\n            BackgroundColor3 = Color3.new(1, 1, 1),\n            Font = Enum.Font.BuilderSans,\n            Text = itemWithUDimRect.item.text,\n            TextColor3 = Color3.new(0, 0, 0),\n            TextSize = 20,\n            Size = UDim2.fromScale(1, 1),\n        })\n    end\nend),\n'})})]})}function m(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}}}]);